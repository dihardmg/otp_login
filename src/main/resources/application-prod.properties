# Server Configuration
server.port=${APP_PORT}

# Database Configuration (PostgreSQL)
spring.datasource.url=${DATABASE_URL}
spring.datasource.username=${POSTGRES_USER}
spring.datasource.password=${POSTGRES_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.hikari.maximum-pool-size=${DB_POOL_SIZE}
spring.datasource.hikari.minimum-idle=${DB_POOL_MIN_IDLE}
spring.datasource.hikari.idle-timeout=${DB_POOL_IDLE_TIMEOUT}
spring.datasource.hikari.max-lifetime=${DB_POOL_MAX_LIFETIME}
spring.datasource.hikari.connection-timeout=${DB_POOL_CONNECTION_TIMEOUT}

# JPA/Hibernate Configuration (Production)
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.defer-datasource-initialization=false
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
spring.jpa.properties.hibernate.cache.use_second_level_cache=false

# Redis Configuration
spring.data.redis.host=${REDIS_HOST}
spring.data.redis.port=${REDIS_PORT}
spring.data.redis.password=${REDIS_PASSWORD}
spring.data.redis.timeout=${REDIS_TIMEOUT}
spring.data.redis.lettuce.pool.max-active=${REDIS_POOL_MAX_ACTIVE}
spring.data.redis.lettuce.pool.max-idle=${REDIS_POOL_MAX_IDLE}
spring.data.redis.lettuce.pool.min-idle=${REDIS_POOL_MIN_IDLE}
spring.data.redis.lettuce.pool.max-wait=-1ms

# Email Configuration (SendGrid)
spring.mail.host=${MAIL_HOST}
spring.mail.port=${MAIL_PORT}
spring.mail.username=${MAIL_USERNAME}
spring.mail.password=${MAIL_PASSWORD}
spring.mail.properties.mail.smtp.auth=${MAIL_SMTP_AUTH}
spring.mail.properties.mail.smtp.starttls.enable=${MAIL_SMTP_STARTTLS}
spring.mail.properties.mail.smtp.trust=${MAIL_SMTP_TRUST}
spring.mail.properties.mail.timeout=${MAIL_TIMEOUT}
spring.mail.debug=${MAIL_DEBUG}

# JWT Configuration
app.jwt.secret=${JWT_SECRET}
app.jwt.access-token-expiration-minutes=${JWT_ACCESS_TOKEN_EXPIRATION_MINUTES}
app.jwt.refresh-token-expiration-days=${JWT_REFRESH_TOKEN_EXPIRATION_DAYS}

# OTP Configuration
app.otp.expiration-minutes=${OTP_EXPIRATION_MINUTES}
app.otp.length=${OTP_LENGTH}
app.otp.max-attempts=${OTP_MAX_ATTEMPTS}

# Email Configuration
app.email.from=${MAIL_FROM}
app.email.otp.template-enabled=true

# Logging Configuration (Production)
logging.level.com.springboot.otplogin=${LOG_LEVEL_APP}
logging.level.org.springframework.security=${LOG_LEVEL_SECURITY}
logging.level.org.springframework.web=${LOG_LEVEL_WEB}
logging.pattern.console=${LOG_PATTERN_CONSOLE}
logging.pattern.file=${LOG_PATTERN_FILE}

# Validation Configuration
spring.mvc.throw-exception-if-no-handler-found=true
spring.web.resources.add-mappings=false

# Actuator Configuration
management.endpoints.web.exposure.include=${MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE}
management.endpoint.health.show-details=${MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS}

# Production Configuration
spring.devtools.restart.enabled=${DEVTOOLS_RESTART_ENABLED}
spring.devtools.livereload.enabled=${DEVTOOLS_LIVERELOAD_ENABLED}

# Rate Limiting Configuration (Production - stricter)
rate.limit.requests-per-minute=${RATE_LIMIT_REQUESTS_PER_MINUTE}
rate.limit.burst-capacity=${RATE_LIMIT_BURST_CAPACITY}